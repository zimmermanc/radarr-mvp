//! PostgreSQL implementation of IndexerRepository

use crate::database::DatabasePool;
use async_trait::async_trait;
use radarr_core::{
    domain::repositories::IndexerRepository,
    models::{Indexer, IndexerImplementation},
    Result,
};
use sqlx::{query, Row};

/// PostgreSQL implementation of IndexerRepository
pub struct PostgresIndexerRepository {
    pool: DatabasePool,
}

impl PostgresIndexerRepository {
    /// Create a new PostgreSQL indexer repository
    pub fn new(pool: DatabasePool) -> Self {
        Self { pool }
    }
}

#[async_trait]
impl IndexerRepository for PostgresIndexerRepository {
    async fn find_by_id(&self, id: i32) -> Result<Option<Indexer>> {
        let row = query!(
            r#"
            SELECT id, name, implementation, settings, enabled, priority,
                   enable_rss, enable_automatic_search, enable_interactive_search,
                   download_client_id, created_at, updated_at
            FROM indexers
            WHERE id = $1
            "#,
            id
        )
        .fetch_optional(&self.pool)
        .await?;

        match row {
            Some(row) => Ok(Some(row_to_indexer(row)?)),
            None => Ok(None),
        }
    }

    async fn find_by_name(&self, name: &str) -> Result<Option<Indexer>> {
        let row = query!(
            r#"
            SELECT id, name, implementation, settings, enabled, priority,
                   enable_rss, enable_automatic_search, enable_interactive_search,
                   download_client_id, created_at, updated_at
            FROM indexers
            WHERE name = $1
            "#,
            name
        )
        .fetch_optional(&self.pool)
        .await?;

        match row {
            Some(row) => Ok(Some(row_to_indexer(row)?)),
            None => Ok(None),
        }
    }

    async fn find_enabled(&self) -> Result<Vec<Indexer>> {
        let rows = query!(
            r#"
            SELECT id, name, implementation, settings, enabled, priority,
                   enable_rss, enable_automatic_search, enable_interactive_search,
                   download_client_id, created_at, updated_at
            FROM indexers
            WHERE enabled = true
            ORDER BY priority ASC, name
            "#
        )
        .fetch_all(&self.pool)
        .await?;

        let mut indexers = Vec::new();
        for row in rows {
            indexers.push(row_to_indexer(row)?);
        }
        Ok(indexers)
    }

    async fn create(&self, indexer: &Indexer) -> Result<Indexer> {
        let row = query!(
            r#"
            INSERT INTO indexers (
                name, implementation, settings, enabled, priority,
                enable_rss, enable_automatic_search, enable_interactive_search,
                download_client_id, created_at, updated_at
            )
            VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
            RETURNING id, name, implementation, settings, enabled, priority,
                      enable_rss, enable_automatic_search, enable_interactive_search,
                      download_client_id, created_at, updated_at
            "#,
            indexer.name,
            indexer.implementation.to_string(),
            indexer.settings,
            indexer.enabled,
            indexer.priority,
            indexer.enable_rss,
            indexer.enable_automatic_search,
            indexer.enable_interactive_search,
            indexer.download_client_id,
            indexer.created_at,
            indexer.updated_at
        )
        .fetch_one(&self.pool)
        .await?;

        row_to_indexer(row)
    }

    async fn update(&self, indexer: &Indexer) -> Result<Indexer> {
        let row = query!(
            r#"
            UPDATE indexers
            SET name = $2, implementation = $3, settings = $4, enabled = $5,
                priority = $6, enable_rss = $7, enable_automatic_search = $8,
                enable_interactive_search = $9, download_client_id = $10,
                updated_at = $11
            WHERE id = $1
            RETURNING id, name, implementation, settings, enabled, priority,
                      enable_rss, enable_automatic_search, enable_interactive_search,
                      download_client_id, created_at, updated_at
            "#,
            indexer.id,
            indexer.name,
            indexer.implementation.to_string(),
            indexer.settings,
            indexer.enabled,
            indexer.priority,
            indexer.enable_rss,
            indexer.enable_automatic_search,
            indexer.enable_interactive_search,
            indexer.download_client_id,
            indexer.updated_at
        )
        .fetch_one(&self.pool)
        .await?;

        row_to_indexer(row)
    }

    async fn delete(&self, id: i32) -> Result<()> {
        query!("DELETE FROM indexers WHERE id = $1", id)
            .execute(&self.pool)
            .await?;

        Ok(())
    }

    async fn list(&self) -> Result<Vec<Indexer>> {
        let rows = query!(
            r#"
            SELECT id, name, implementation, settings, enabled, priority,
                   enable_rss, enable_automatic_search, enable_interactive_search,
                   download_client_id, created_at, updated_at
            FROM indexers
            ORDER BY priority ASC, name
            "#
        )
        .fetch_all(&self.pool)
        .await?;

        let mut indexers = Vec::new();
        for row in rows {
            indexers.push(row_to_indexer(row)?);
        }
        Ok(indexers)
    }

    async fn test_connection(&self, id: i32) -> Result<bool> {
        // This is a placeholder implementation
        // In a real implementation, this would test the actual connection to the indexer
        let indexer = self.find_by_id(id).await?;
        match indexer {
            Some(_) => Ok(true), // Assume connection is okay if indexer exists
            None => Ok(false),
        }
    }
}

// Helper functions

fn row_to_indexer(row: impl Row + sqlx::postgres::PgRow) -> Result<Indexer> {
    let implementation_str: String = row.try_get("implementation")?;
    let implementation = parse_indexer_implementation(&implementation_str)?;

    Ok(Indexer {
        id: row.try_get("id")?,
        name: row.try_get("name")?,
        implementation,
        settings: row.try_get("settings")?,
        enabled: row.try_get("enabled")?,
        priority: row.try_get("priority")?,
        enable_rss: row.try_get("enable_rss")?,
        enable_automatic_search: row.try_get("enable_automatic_search")?,
        enable_interactive_search: row.try_get("enable_interactive_search")?,
        download_client_id: row.try_get("download_client_id")?,
        created_at: row.try_get("created_at")?,
        updated_at: row.try_get("updated_at")?,
    })
}

fn parse_indexer_implementation(implementation_str: &str) -> Result<IndexerImplementation> {
    match implementation_str {
        "prowlarr" => Ok(IndexerImplementation::Prowlarr),
        "jackett" => Ok(IndexerImplementation::Jackett),
        "torznab" => Ok(IndexerImplementation::Torznab),
        "newznab" => Ok(IndexerImplementation::Newznab),
        _ => Err(radarr_core::RadarrError::ValidationError {
            field: "implementation".to_string(),
            message: format!("Invalid indexer implementation: {}", implementation_str),
        }),
    }
}

// Implement Display for enum serialization to string
impl std::fmt::Display for IndexerImplementation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            IndexerImplementation::Prowlarr => write!(f, "prowlarr"),
            IndexerImplementation::Jackett => write!(f, "jackett"),
            IndexerImplementation::Torznab => write!(f, "torznab"),
            IndexerImplementation::Newznab => write!(f, "newznab"),
        }
    }
}