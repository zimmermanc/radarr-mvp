//! PostgreSQL implementation of MovieRepository

use crate::database::DatabasePool;
use async_trait::async_trait;
use radarr_core::{
    domain::repositories::MovieRepository,
    models::{Movie, MovieStatus, MinimumAvailability},
    Result,
};
use sqlx::{query, Row, FromRow};
use uuid::Uuid;

/// PostgreSQL implementation of MovieRepository
pub struct PostgresMovieRepository {
    pool: DatabasePool,
}

impl PostgresMovieRepository {
    /// Create a new PostgreSQL movie repository
    pub fn new(pool: DatabasePool) -> Self {
        Self { pool }
    }
}

#[async_trait]
impl MovieRepository for PostgresMovieRepository {
    async fn find_by_id(&self, id: Uuid) -> Result<Option<Movie>> {
        let row = sqlx::query(
            r#"
            SELECT id, tmdb_id, imdb_id, title, original_title, year, runtime,
                   status, monitored, quality_profile_id, minimum_availability,
                   has_file, movie_file_id, metadata, alternative_titles,
                   created_at, updated_at, last_search_time, last_info_sync
            FROM movies
            WHERE id = $1
            "#
        )
        .bind(id)
        .fetch_optional(&self.pool)
        .await?;

        match row {
            Some(row) => Ok(Some(row_to_movie(row)?)),
            None => Ok(None),
        }
    }

    async fn find_by_tmdb_id(&self, tmdb_id: i32) -> Result<Option<Movie>> {
        let row = query!(
            r#"
            SELECT id, tmdb_id, imdb_id, title, original_title, year, runtime,
                   status, monitored, quality_profile_id, minimum_availability,
                   has_file, movie_file_id, metadata, alternative_titles,
                   created_at, updated_at, last_search_time, last_info_sync
            FROM movies
            WHERE tmdb_id = $1
            "#,
            tmdb_id
        )
        .fetch_optional(&self.pool)
        .await?;

        match row {
            Some(row) => Ok(Some(row_to_movie(row)?)),
            None => Ok(None),
        }
    }

    async fn find_by_imdb_id(&self, imdb_id: &str) -> Result<Option<Movie>> {
        let row = query!(
            r#"
            SELECT id, tmdb_id, imdb_id, title, original_title, year, runtime,
                   status, monitored, quality_profile_id, minimum_availability,
                   has_file, movie_file_id, metadata, alternative_titles,
                   created_at, updated_at, last_search_time, last_info_sync
            FROM movies
            WHERE imdb_id = $1
            "#,
            imdb_id
        )
        .fetch_optional(&self.pool)
        .await?;

        match row {
            Some(row) => Ok(Some(row_to_movie(row)?)),
            None => Ok(None),
        }
    }

    async fn find_monitored(&self) -> Result<Vec<Movie>> {
        let rows = query!(
            r#"
            SELECT id, tmdb_id, imdb_id, title, original_title, year, runtime,
                   status, monitored, quality_profile_id, minimum_availability,
                   has_file, movie_file_id, metadata, alternative_titles,
                   created_at, updated_at, last_search_time, last_info_sync
            FROM movies
            WHERE monitored = true
            ORDER BY title
            "#
        )
        .fetch_all(&self.pool)
        .await?;

        let mut movies = Vec::new();
        for row in rows {
            movies.push(row_to_movie(row)?);
        }
        Ok(movies)
    }

    async fn find_missing_files(&self) -> Result<Vec<Movie>> {
        let rows = query!(
            r#"
            SELECT id, tmdb_id, imdb_id, title, original_title, year, runtime,
                   status, monitored, quality_profile_id, minimum_availability,
                   has_file, movie_file_id, metadata, alternative_titles,
                   created_at, updated_at, last_search_time, last_info_sync
            FROM movies
            WHERE has_file = false AND monitored = true
            ORDER BY year DESC, title
            "#
        )
        .fetch_all(&self.pool)
        .await?;

        let mut movies = Vec::new();
        for row in rows {
            movies.push(row_to_movie(row)?);
        }
        Ok(movies)
    }

    async fn search_by_title(&self, query_text: &str, limit: i32) -> Result<Vec<Movie>> {
        let rows = query!(
            r#"
            SELECT id, tmdb_id, imdb_id, title, original_title, year, runtime,
                   status, monitored, quality_profile_id, minimum_availability,
                   has_file, movie_file_id, metadata, alternative_titles,
                   created_at, updated_at, last_search_time, last_info_sync,
                   ts_rank(search_vector, plainto_tsquery('english', $1)) as rank
            FROM movies
            WHERE search_vector @@ plainto_tsquery('english', $1)
            ORDER BY rank DESC, title
            LIMIT $2
            "#,
            query_text,
            limit
        )
        .fetch_all(&self.pool)
        .await?;

        let mut movies = Vec::new();
        for row in rows {
            movies.push(row_to_movie_with_rank(row)?);
        }
        Ok(movies)
    }

    async fn create(&self, movie: &Movie) -> Result<Movie> {
        let row = query!(
            r#"
            INSERT INTO movies (
                id, tmdb_id, imdb_id, title, original_title, year, runtime,
                status, monitored, quality_profile_id, minimum_availability,
                has_file, movie_file_id, metadata, alternative_titles,
                created_at, updated_at, last_search_time, last_info_sync
            )
            VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19)
            RETURNING id, tmdb_id, imdb_id, title, original_title, year, runtime,
                      status, monitored, quality_profile_id, minimum_availability,
                      has_file, movie_file_id, metadata, alternative_titles,
                      created_at, updated_at, last_search_time, last_info_sync
            "#,
            movie.id,
            movie.tmdb_id,
            movie.imdb_id,
            movie.title,
            movie.original_title,
            movie.year,
            movie.runtime,
            movie.status.to_string(),
            movie.monitored,
            movie.quality_profile_id,
            movie.minimum_availability.to_string(),
            movie.has_file,
            movie.movie_file_id,
            movie.metadata,
            movie.alternative_titles,
            movie.created_at,
            movie.updated_at,
            movie.last_search_time,
            movie.last_info_sync
        )
        .fetch_one(&self.pool)
        .await?;

        row_to_movie(row)
    }

    async fn update(&self, movie: &Movie) -> Result<Movie> {
        let row = query!(
            r#"
            UPDATE movies
            SET tmdb_id = $2, imdb_id = $3, title = $4, original_title = $5,
                year = $6, runtime = $7, status = $8, monitored = $9,
                quality_profile_id = $10, minimum_availability = $11,
                has_file = $12, movie_file_id = $13, metadata = $14,
                alternative_titles = $15, updated_at = $16,
                last_search_time = $17, last_info_sync = $18
            WHERE id = $1
            RETURNING id, tmdb_id, imdb_id, title, original_title, year, runtime,
                      status, monitored, quality_profile_id, minimum_availability,
                      has_file, movie_file_id, metadata, alternative_titles,
                      created_at, updated_at, last_search_time, last_info_sync
            "#,
            movie.id,
            movie.tmdb_id,
            movie.imdb_id,
            movie.title,
            movie.original_title,
            movie.year,
            movie.runtime,
            movie.status.to_string(),
            movie.monitored,
            movie.quality_profile_id,
            movie.minimum_availability.to_string(),
            movie.has_file,
            movie.movie_file_id,
            movie.metadata,
            movie.alternative_titles,
            movie.updated_at,
            movie.last_search_time,
            movie.last_info_sync
        )
        .fetch_one(&self.pool)
        .await?;

        row_to_movie(row)
    }

    async fn delete(&self, id: Uuid) -> Result<()> {
        query!("DELETE FROM movies WHERE id = $1", id)
            .execute(&self.pool)
            .await?;

        Ok(())
    }

    async fn list(&self, offset: i64, limit: i32) -> Result<Vec<Movie>> {
        let rows = query!(
            r#"
            SELECT id, tmdb_id, imdb_id, title, original_title, year, runtime,
                   status, monitored, quality_profile_id, minimum_availability,
                   has_file, movie_file_id, metadata, alternative_titles,
                   created_at, updated_at, last_search_time, last_info_sync
            FROM movies
            ORDER BY title
            OFFSET $1 LIMIT $2
            "#,
            offset,
            limit
        )
        .fetch_all(&self.pool)
        .await?;

        let mut movies = Vec::new();
        for row in rows {
            movies.push(row_to_movie(row)?);
        }
        Ok(movies)
    }

    async fn count(&self) -> Result<i64> {
        let row = query!("SELECT COUNT(*) as count FROM movies")
            .fetch_one(&self.pool)
            .await?;

        Ok(row.count.unwrap_or(0))
    }

    async fn update_last_search_time(&self, id: Uuid) -> Result<()> {
        query!(
            "UPDATE movies SET last_search_time = NOW(), updated_at = NOW() WHERE id = $1",
            id
        )
        .execute(&self.pool)
        .await?;

        Ok(())
    }
}

// Helper functions to convert database rows to domain models

fn row_to_movie(row: impl Row + sqlx::postgres::PgRow) -> Result<Movie> {
    let status_str: String = row.try_get("status")?;
    let status = parse_movie_status(&status_str)?;
    
    let min_availability_str: String = row.try_get("minimum_availability")?;
    let minimum_availability = parse_minimum_availability(&min_availability_str)?;

    Ok(Movie {
        id: row.try_get("id")?,
        tmdb_id: row.try_get("tmdb_id")?,
        imdb_id: row.try_get("imdb_id")?,
        title: row.try_get("title")?,
        original_title: row.try_get("original_title")?,
        year: row.try_get("year")?,
        runtime: row.try_get("runtime")?,
        status,
        monitored: row.try_get("monitored")?,
        quality_profile_id: row.try_get("quality_profile_id")?,
        minimum_availability,
        has_file: row.try_get("has_file")?,
        movie_file_id: row.try_get("movie_file_id")?,
        metadata: row.try_get("metadata")?,
        alternative_titles: row.try_get("alternative_titles")?,
        created_at: row.try_get("created_at")?,
        updated_at: row.try_get("updated_at")?,
        last_search_time: row.try_get("last_search_time")?,
        last_info_sync: row.try_get("last_info_sync")?,
    })
}

fn row_to_movie_with_rank(row: impl Row + sqlx::postgres::PgRow) -> Result<Movie> {
    // For search results, we ignore the rank column and just extract the movie
    row_to_movie(row)
}

fn parse_movie_status(status_str: &str) -> Result<MovieStatus> {
    match status_str {
        "announced" => Ok(MovieStatus::Announced),
        "in_production" => Ok(MovieStatus::InProduction),
        "post_production" => Ok(MovieStatus::PostProduction),
        "released" => Ok(MovieStatus::Released),
        "cancelled" => Ok(MovieStatus::Cancelled),
        _ => Err(radarr_core::RadarrError::ValidationError {
            field: "status".to_string(),
            message: format!("Invalid movie status: {}", status_str),
        }),
    }
}

fn parse_minimum_availability(availability_str: &str) -> Result<MinimumAvailability> {
    match availability_str {
        "announced" => Ok(MinimumAvailability::Announced),
        "in_cinemas" => Ok(MinimumAvailability::InCinemas),
        "released" => Ok(MinimumAvailability::Released),
        "predb" => Ok(MinimumAvailability::Predb),
        _ => Err(radarr_core::RadarrError::ValidationError {
            field: "minimum_availability".to_string(),
            message: format!("Invalid minimum availability: {}", availability_str),
        }),
    }
}

// Implement Display for enum serialization to string
impl std::fmt::Display for MovieStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            MovieStatus::Announced => write!(f, "announced"),
            MovieStatus::InProduction => write!(f, "in_production"),
            MovieStatus::PostProduction => write!(f, "post_production"),
            MovieStatus::Released => write!(f, "released"),
            MovieStatus::Cancelled => write!(f, "cancelled"),
        }
    }
}

impl std::fmt::Display for MinimumAvailability {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            MinimumAvailability::Announced => write!(f, "announced"),
            MinimumAvailability::InCinemas => write!(f, "in_cinemas"),
            MinimumAvailability::Released => write!(f, "released"),
            MinimumAvailability::Predb => write!(f, "predb"),
        }
    }
}