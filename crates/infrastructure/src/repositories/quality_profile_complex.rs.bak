//! PostgreSQL implementation of QualityProfileRepository

use crate::database::DatabasePool;
use async_trait::async_trait;
use radarr_core::{
    domain::repositories::QualityProfileRepository,
    models::QualityProfile,
    Result,
};
use sqlx::{query, Row};

/// PostgreSQL implementation of QualityProfileRepository
pub struct PostgresQualityProfileRepository {
    pool: DatabasePool,
}

impl PostgresQualityProfileRepository {
    /// Create a new PostgreSQL quality profile repository
    pub fn new(pool: DatabasePool) -> Self {
        Self { pool }
    }
}

#[async_trait]
impl QualityProfileRepository for PostgresQualityProfileRepository {
    async fn find_by_id(&self, id: i32) -> Result<Option<QualityProfile>> {
        let row = query!(
            r#"
            SELECT id, name, cutoff_quality_id, upgrade_allowed, items, language,
                   created_at, updated_at
            FROM quality_profiles
            WHERE id = $1
            "#,
            id
        )
        .fetch_optional(&self.pool)
        .await?;

        match row {
            Some(row) => Ok(Some(row_to_quality_profile(row)?)),
            None => Ok(None),
        }
    }

    async fn find_by_name(&self, name: &str) -> Result<Option<QualityProfile>> {
        let row = query!(
            r#"
            SELECT id, name, cutoff_quality_id, upgrade_allowed, items, language,
                   created_at, updated_at
            FROM quality_profiles
            WHERE name = $1
            "#,
            name
        )
        .fetch_optional(&self.pool)
        .await?;

        match row {
            Some(row) => Ok(Some(row_to_quality_profile(row)?)),
            None => Ok(None),
        }
    }

    async fn create(&self, profile: &QualityProfile) -> Result<QualityProfile> {
        let row = query!(
            r#"
            INSERT INTO quality_profiles (
                name, cutoff_quality_id, upgrade_allowed, items, language,
                created_at, updated_at
            )
            VALUES ($1, $2, $3, $4, $5, $6, $7)
            RETURNING id, name, cutoff_quality_id, upgrade_allowed, items, language,
                      created_at, updated_at
            "#,
            profile.name,
            profile.cutoff_quality_id,
            profile.upgrade_allowed,
            profile.items,
            profile.language,
            profile.created_at,
            profile.updated_at
        )
        .fetch_one(&self.pool)
        .await?;

        row_to_quality_profile(row)
    }

    async fn update(&self, profile: &QualityProfile) -> Result<QualityProfile> {
        let row = query!(
            r#"
            UPDATE quality_profiles
            SET name = $2, cutoff_quality_id = $3, upgrade_allowed = $4,
                items = $5, language = $6, updated_at = $7
            WHERE id = $1
            RETURNING id, name, cutoff_quality_id, upgrade_allowed, items, language,
                      created_at, updated_at
            "#,
            profile.id,
            profile.name,
            profile.cutoff_quality_id,
            profile.upgrade_allowed,
            profile.items,
            profile.language,
            profile.updated_at
        )
        .fetch_one(&self.pool)
        .await?;

        row_to_quality_profile(row)
    }

    async fn delete(&self, id: i32) -> Result<()> {
        // Check if any movies are using this quality profile
        let count = query!(
            "SELECT COUNT(*) as count FROM movies WHERE quality_profile_id = $1",
            id
        )
        .fetch_one(&self.pool)
        .await?;

        if count.count.unwrap_or(0) > 0 {
            return Err(radarr_core::RadarrError::ValidationError {
                field: "quality_profile_id".to_string(),
                message: "Cannot delete quality profile that is in use by movies".to_string(),
            });
        }

        query!("DELETE FROM quality_profiles WHERE id = $1", id)
            .execute(&self.pool)
            .await?;

        Ok(())
    }

    async fn list(&self) -> Result<Vec<QualityProfile>> {
        let rows = query!(
            r#"
            SELECT id, name, cutoff_quality_id, upgrade_allowed, items, language,
                   created_at, updated_at
            FROM quality_profiles
            ORDER BY name
            "#
        )
        .fetch_all(&self.pool)
        .await?;

        let mut profiles = Vec::new();
        for row in rows {
            profiles.push(row_to_quality_profile(row)?);
        }
        Ok(profiles)
    }

    async fn get_default(&self) -> Result<Option<QualityProfile>> {
        // Return the first quality profile as default
        let row = query!(
            r#"
            SELECT id, name, cutoff_quality_id, upgrade_allowed, items, language,
                   created_at, updated_at
            FROM quality_profiles
            ORDER BY id
            LIMIT 1
            "#
        )
        .fetch_optional(&self.pool)
        .await?;

        match row {
            Some(row) => Ok(Some(row_to_quality_profile(row)?)),
            None => Ok(None),
        }
    }
}

// Helper functions

fn row_to_quality_profile(row: impl Row + sqlx::postgres::PgRow) -> Result<QualityProfile> {
    Ok(QualityProfile {
        id: row.try_get("id")?,
        name: row.try_get("name")?,
        cutoff_quality_id: row.try_get("cutoff_quality_id")?,
        upgrade_allowed: row.try_get("upgrade_allowed")?,
        items: row.try_get("items")?,
        language: row.try_get("language")?,
        created_at: row.try_get("created_at")?,
        updated_at: row.try_get("updated_at")?,
    })
}