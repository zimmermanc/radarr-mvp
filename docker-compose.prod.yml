# Docker Compose Production Configuration
# =====================================
# Use with: docker-compose -f docker-compose.yml -f docker-compose.prod.yml up

version: '3.8'

services:
  radarr:
    build:
      target: production  # Use optimized production build
    restart: always  # Always restart in production
    
    environment:
      # Production logging
      RUST_LOG: warn  # Less verbose logging
      LOG_JSON_FORMAT: true  # Structured logging for aggregation
      
      # Security settings
      API_KEY_REQUIRED: true
      CORS_ALLOWED_ORIGINS: ${CORS_ALLOWED_ORIGINS:-""}  # Restricted CORS
      
      # Production database settings
      DATABASE_MAX_CONNECTIONS: ${DATABASE_MAX_CONNECTIONS:-20}
      DATABASE_LOG_QUERIES: false
      DATABASE_HEALTH_CHECK_ENABLED: true
      DATABASE_QUERY_TIMEOUT: 30
      
      # Performance optimizations
      RADARR_MAX_CONNECTIONS: ${RADARR_MAX_CONNECTIONS:-2000}
      MAX_MEMORY_USAGE_MB: ${MAX_MEMORY_USAGE_MB:-512}
      
      # Production import settings
      IMPORT_DRY_RUN: false
      IMPORT_MAX_PARALLEL: ${IMPORT_MAX_PARALLEL:-6}
      
      # Connection retry settings
      CONNECTION_RETRY_ATTEMPTS: 5
      CONNECTION_RETRY_DELAY: 10
      
      # Disable development features
      DEVELOPMENT_MODE: false
      MOCK_PROWLARR: false
      MOCK_QBITTORRENT: false
    
    # Production resource limits
    deploy:
      resources:
        limits:
          cpus: '${RADARR_CPU_LIMIT:-2.0}'
          memory: ${RADARR_MEMORY_LIMIT:-1G}
        reservations:
          cpus: '${RADARR_CPU_RESERVATION:-0.5}'
          memory: ${RADARR_MEMORY_RESERVATION:-512M}
    
    # Production volumes (no source code mounting)
    volumes:
      # Only mount production data and config
      - ${MOVIES_PATH:-/opt/radarr/movies}:/movies:rw
      - ${DOWNLOADS_PATH:-/opt/radarr/downloads}:/downloads:rw
      - radarr_config:/app/config:rw
      - radarr_logs:/app/logs:rw
      
      # Production configuration overrides
      - ${RADARR_CONFIG_PATH:-./config/prod}:/app/config/custom:ro
      
      # SSL certificates if using HTTPS
      - ${SSL_CERT_PATH:-./certs}:/app/certs:ro
    
    # Production health check (strict)
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:7878/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    
    # Security hardening
    security_opt:
      - no-new-privileges:true
    read_only: true
    tmpfs:
      - /tmp:rw,size=100m,mode=1777
      - /app/temp:rw,size=50m,mode=755
    
    # Logging configuration for production
    logging:
      driver: "json-file"
      options:
        max-size: "100m"
        max-file: "10"
        labels: "service,version,environment"
        tag: "radarr-mvp|{{.Name}}"

  postgres:
    restart: always
    
    environment:
      # Production database credentials (use strong passwords)
      POSTGRES_DB: ${POSTGRES_DB:-radarr}
      POSTGRES_USER: ${POSTGRES_USER:-radarr}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}  # Must be set in .env
      
      # Production PostgreSQL settings
      POSTGRES_INITDB_ARGS: "--encoding=UTF-8 --locale=C --data-checksums"
    
    # Production resource limits
    deploy:
      resources:
        limits:
          cpus: '${POSTGRES_CPU_LIMIT:-1.0}'
          memory: ${POSTGRES_MEMORY_LIMIT:-1G}
        reservations:
          cpus: '${POSTGRES_CPU_RESERVATION:-0.2}'
          memory: ${POSTGRES_MEMORY_RESERVATION:-256M}
    
    # Don't expose ports in production (internal access only)
    ports: []
    
    # Production database configuration
    command: >
      postgres
      -c max_connections=${POSTGRES_MAX_CONNECTIONS:-100}
      -c shared_buffers=${POSTGRES_SHARED_BUFFERS:-256MB}
      -c effective_cache_size=${POSTGRES_EFFECTIVE_CACHE_SIZE:-1GB}
      -c work_mem=${POSTGRES_WORK_MEM:-4MB}
      -c maintenance_work_mem=${POSTGRES_MAINTENANCE_WORK_MEM:-64MB}
      -c checkpoint_completion_target=0.9
      -c wal_buffers=16MB
      -c default_statistics_target=100
      -c random_page_cost=1.1
      -c effective_io_concurrency=200
      -c log_min_duration_statement=${POSTGRES_LOG_SLOW_QUERIES:-1000}
      -c log_checkpoints=on
      -c log_connections=on
      -c log_disconnections=on
      -c log_temp_files=0
    
    volumes:
      # Production database backups
      - ${POSTGRES_BACKUP_PATH:-./backups/postgres}:/backups:rw
      
      # Production initialization scripts
      - ./scripts/prod-db-init.sql:/docker-entrypoint-initdb.d/prod-init.sql:ro
    
    logging:
      driver: "json-file"
      options:
        max-size: "50m"
        max-file: "5"

  redis:
    restart: always
    
    # Production resource limits
    deploy:
      resources:
        limits:
          cpus: '${REDIS_CPU_LIMIT:-0.5}'
          memory: ${REDIS_MEMORY_LIMIT:-512M}
        reservations:
          cpus: '${REDIS_CPU_RESERVATION:-0.1}'
          memory: ${REDIS_MEMORY_RESERVATION:-128M}
    
    # Don't expose ports in production
    ports: []
    
    # Production Redis configuration
    command: >
      redis-server
      --appendonly yes
      --appendfsync everysec
      --maxmemory ${REDIS_MAX_MEMORY:-256mb}
      --maxmemory-policy allkeys-lru
      --tcp-keepalive 300
      --timeout 0
      --tcp-backlog 511
      --databases 16
      --save 900 1
      --save 300 10
      --save 60 10000
      --stop-writes-on-bgsave-error yes
      --rdbcompression yes
      --rdbchecksum yes
      --dir /data
      --requirepass ${REDIS_PASSWORD}
    
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

# Production volume configuration with backup considerations
volumes:
  postgres_data:
    driver: local
    driver_opts:
      type: none
      device: ${POSTGRES_DATA_PATH:-/opt/radarr/postgres}
      o: bind
  
  redis_data:
    driver: local
    driver_opts:
      type: none  
      device: ${REDIS_DATA_PATH:-/opt/radarr/redis}
      o: bind
  
  radarr_config:
    driver: local
    driver_opts:
      type: none
      device: ${RADARR_CONFIG_DATA_PATH:-/opt/radarr/config}
      o: bind
  
  radarr_logs:
    driver: local
    driver_opts:
      type: none
      device: ${RADARR_LOGS_PATH:-/opt/radarr/logs}
      o: bind

# Production network with security considerations
networks:
  radarr-network:
    driver: bridge
    ipam:
      config:
        - subnet: ${DOCKER_SUBNET:-172.20.0.0/16}
    driver_opts:
      com.docker.network.bridge.name: radarr-prod
      com.docker.network.bridge.enable_ip_masquerade: "true"
      com.docker.network.bridge.enable_icc: "false"  # Disable inter-container communication by default